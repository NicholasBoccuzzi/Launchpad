// Implement a method to perform basic string compression using the counts of
// repeated characters. For example, the string 'aabcccccaaa' would become a2b1c5a3.
// If the 'compressed' string woul dnot become smaller than the original string,
// your method should return the original string. You can assume the string has only
// uppercase and lowercase letters (a-z).

// Make two pointers. One will point to the origins of the first sequential character.
// One will point ahead to the last sequential character

// If the next sequential character of the last pointer is not the first character,
// then generate the compression.


const letterCounter = (string) => {
  let curLetter;
  let curCount = 0;
  let returnString = "";

  for (var i = 0; i < string.length; i++) {
    if (i === 0) {
      curLetter = string[i];
    }

    if (string[i] === curLetter) {
      curCount += 1;
    } else {
      returnString += `${curLetter}${curCount}`;
      curLetter = string[i];
      curCount = 1;
    }

    if (i === string.length - 1) {
      returnString += `${curLetter}${curCount}`;
    }
  }

  if (returnString.length < string.length) {
    return returnString;
  } else {
    return string;
  }
};


// "aabbbc"
// 4,2,3,10,2

class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }

  next (node) {
    this.next = node;
  }
}

let head = new Node (6);
let nodeB = new Node (2);
let nodeC = new Node (3);
let nodeD = new Node (10);
let nodeE = new Node (2);

head.next = nodeB;
nodeB.next = nodeC;
nodeC.next = nodeD;
nodeE.next = nodeE;

let next = true;
let runner = head;
let count = 1;

while (next) {
  count += 1;
  if (runner.next) {
    runner = runner.next;
  } else {
    next = false;
  }
}

const factorials = (n)=> {
  if (n <= 1) {
    return 1;
  } else {
    return n * factorials(n - 1);
  }
};



// A child is running up a staircase with n steps and can hop either 1 step, 2 steps,
// or 3 steps at a time. Implement a method to count how many possible ways the child
// can run up the stairs.


base cases: n === 1 {
  possible solutions: [1]
return 1;
}
n === 2 {
  return 2
}

n === 3 {
  return 3;
}

n === 4 {
}

// Implement a method to perform basic string compression using the counts of
// repeated characters. For example, the string 'aabcccccaaa' would become a2b1c5a3.
// If the 'compressed' string woul dnot become smaller than the original string,
// your method should return the original string. You can assume the string has only
// uppercase and lowercase letters (a-z).

const compressString = (string) => {
  let result = "";
  let curLetter = "";
  let curCount = 0;

  for (var i = 0; i < string.length; i++) {
    if (curLetter === "") {
      curLetter = string[i];
      curCount += 1;
    } else if (string[i] !== curLetter) {
      curCount += 1;
      result += curLetter;
      result += curCount.toString();
      curLetter = string[i]
      curCount = 0;
    } else {
      curCount += 1;
    }
    if (i === string.length - 1) {
      result += curLetter;
      result += curCount.toString();
    }
  }


  if (result.length < string.length) {
    return result;
  } else {
    return string;
  }
}


const fibonacci = (num) => {
  if (num <= 0) {
    return [];
  } else if (num === 1) {
    return [1];
  } else if (num === 2) {
    return [1, 1];
  }

  let recursion = fibonacci(num - 1)
  console.log(recursion)
  recursion.push(fibonacci(num - 1)[fibonacci(num - 1).length - 1] + fibonacci(num - 1)[fibonacci(num - 1).length - 2])
  return recursion;
}


function mergeSort (arr) {
    if (arr.length < 2) {
      return arr;
    }

    var mid = Math.floor(arr.length / 2);
    var subLeft = mergeSort(arr.slice(0, mid));
    var subRight = mergeSort(arr.slice(mid));

    return merge(subLeft, subRight);
}

function merge (node1, node2) {
    var result = [];
    while (node1.length > 0 && node2.length > 0)
        result.push(node1[0] < node2[0]? node1.shift() : node2.shift());
    return result.concat(node1.length? node1 : node2);
}


const mergeSort = (arr) => {
  if (arr.length < 2) {
    return arr;
  }

  let mid = arr.length/2;
  let left = arr.slice(0, mid);
  let right = arr.slice(mid);

  return merge(mergeSort(left), mergeSort(right));
}

const merge = (arr1, arr2) => {
  let returnArr = [];

  while (arr1.length > 0 && arr2.length > 0) {
    if (arr1[0] < arr2[0]) {
      returnArr.push(arr1.shift());
    } else {
      returnArr.push(arr2.shift());
    }
  }

  return returnArr.concat(arr1.length? arr1 : arr2)
}


const quickSort = (arr) => {
  if (arr.length < 2) {
    return arr;
  }

  let pivot = arr.shift();
  let left = [];
  let right = [];

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  return quickSort(left).concat([pivot]).concat(quickSort(right));
}

const maxInBinaryTree = (tree) => {
  if (!tree.left && !tree.right) {
    return tree.value;
  } else {
    tree
  }
}


const fibonacci = (num) => {
  if (num === 0) {
    return [];
  } else if (num === 1) {
    return [1];
  } else if (num === 2) {
    return [1, 1];
  }

  let recursion = fibonacci(num - 1)
  recursion.push(fibonacci(num - 1)[fibonacci(num - 1).length - 1] + fibonacci(num - 1)[fibonacci(num - 1).length - 2]);
  return recursion;
}

const fibonacci = num => {
  if (num === 0 ) {
    return [];
  } else if (num === 1) {
    return [1];
  } else if (num === 2) {
    return [1, 1]
  }

  let returnArray = [1, 1]

  while (returnArray.length < num) {
    let last = returnArray[returnArray.length - 1];
    let secondToLast = returnArray[returnArray.length - 2];

    returnArray.push(last + secondToLast);
  }

  return returnArray;
}

const binarySearch = (arr, num) => {
  if (arr.length && arr.length > 1) {
    let mid = arr[Math.floor(arr.length/2)]
    if (num > mid) {
      let right = arr.slice(0, mid);
      return binarySearch(right, num);
    } else if (num < mid){
      let left = arr.slice(mid);
      return binarySearch(left, num);
    } else if (num === mid) {
      return true;
    }

  } else if (arr[0] && arr[0] === num){
    return true;
  } else {
    return false;
  }
}


const mergeSort = (arr) => {
  if (arr.length <= 1) {
  return arr;
  }

  let mid = (arr.length/2);
  let left = arr.slice(0, mid);
  let right = arr.slice(mid);

  return merge(mergeSort(left), mergeSort(right));
}

const merge = (left, right) => {
  let returnArray = [];

  while(left.length > 0 && right.length > 0) {
    if (left[0] < right[0]) {
      returnArray.push(left.shift())
    } else {
      returnArray.push(right.shift())
    }
  }

  return returnArray.concat(left).concat(right);
}

const quickSort = (arr) => {
  if (arr.length <= 1 ) {
    return arr;
  }

  let pivot = arr.shift();
  let left = [];
  let right = [];

  for (var i = 0; i < arr.length; i++) {
    if (arr[0] < pivot) {
      left.push(arr.shift());
    } else {
      right.push(arr.shift());
    }
  }

   quickSort(left).push(pivot)
  concat(quickSort(right))
}

const fibonacciSum = (num) => {
  if (num <= 0) {
    return 0;
  } else if (num === 1) {
    return 1;
  } else if (num === 2) {
    return 2;
  } else {
    let s = fibonacciSum(num - 1);

    return fibonacciSum(num - 1) + fibonacciSum(num - 2);
  }
}

const allFibNums = (num) => {
  let sum = 0;

  for(var i = 0; i < num; i++) {
    sum += fibonacciSum(i);
  }

  return sum
}

const longestConsecSubstring = (string) => {
  if (string === "") {
    return [-1, 0]
  } else if (string.length === 1) {
    return [0, 1]
  }

  let currentLetter = string[0];
  let currentCount = 0;
  let currentLongestCount = 0;
  let result = [];
  let currentStartIndex = 0;

  for (var i = 0; i < string.length; i++) {
    if (string[i] === currentLetter) {
      currentCount += 1;
      if (currentLongestCount < currentCount) {
        result = [currentStartIndex, currentCount];
      }
    } else {
      if (currentLongestCount < currentCount) {
        result = [currentStartIndex, currentCount];
        currentCount = 1;
      }
      currentStartIndex = i;
      currentCount = 1;
    }
  }

  return result;
}
